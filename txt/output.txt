INTTK int 1
IDENFR buf 1
LBRACK [ 1
INTCON 2 1
RBRACK ] 1
LBRACK [ 1
INTCON 100 1
RBRACK ] 1
SEMICN ; 1
VOIDTK void 4
IDENFR merge_sort 4
LPARENT ( 4
INTTK int 4
IDENFR l 4
COMMA , 4
INTTK int 4
IDENFR r 4
RPARENT ) 4
LBRACE { 5
IFTK if 6
LPARENT ( 6
IDENFR l 6
PLUS + 6
INTCON 1 6
GEQ >= 6
IDENFR r 6
RPARENT ) 6
RETURNTK return 7
SEMICN ; 7
INTTK int 9
IDENFR mid 9
ASSIGN = 9
LPARENT ( 9
IDENFR l 9
PLUS + 9
IDENFR r 9
RPARENT ) 9
DIV / 9
INTCON 2 9
SEMICN ; 9
IDENFR merge_sort 10
LPARENT ( 10
IDENFR l 10
COMMA , 10
IDENFR mid 10
RPARENT ) 10
SEMICN ; 10
IDENFR merge_sort 11
LPARENT ( 11
IDENFR mid 11
COMMA , 11
IDENFR r 11
RPARENT ) 11
SEMICN ; 11
INTTK int 13
IDENFR i 13
ASSIGN = 13
IDENFR l 13
COMMA , 13
IDENFR j 13
ASSIGN = 13
IDENFR mid 13
COMMA , 13
IDENFR k 13
ASSIGN = 13
IDENFR l 13
SEMICN ; 13
WHILETK while 14
LPARENT ( 14
IDENFR i 14
LSS < 14
IDENFR mid 14
AND && 14
IDENFR j 14
LSS < 14
IDENFR r 14
RPARENT ) 14
LBRACE { 14
IFTK if 15
LPARENT ( 15
IDENFR buf 15
LBRACK [ 15
INTCON 0 15
RBRACK ] 15
LBRACK [ 15
IDENFR i 15
RBRACK ] 15
LSS < 15
IDENFR buf 15
LBRACK [ 15
INTCON 0 15
RBRACK ] 15
LBRACK [ 15
IDENFR j 15
RBRACK ] 15
RPARENT ) 15
LBRACE { 15
IDENFR buf 16
LBRACK [ 16
INTCON 1 16
RBRACK ] 16
LBRACK [ 16
IDENFR k 16
RBRACK ] 16
ASSIGN = 16
IDENFR buf 16
LBRACK [ 16
INTCON 0 16
RBRACK ] 16
LBRACK [ 16
IDENFR i 16
RBRACK ] 16
SEMICN ; 16
IDENFR i 17
ASSIGN = 17
IDENFR i 17
PLUS + 17
INTCON 1 17
SEMICN ; 17
RBRACE } 18
ELSETK else 18
LBRACE { 18
IDENFR buf 19
LBRACK [ 19
INTCON 1 19
RBRACK ] 19
LBRACK [ 19
IDENFR k 19
RBRACK ] 19
ASSIGN = 19
IDENFR buf 19
LBRACK [ 19
INTCON 0 19
RBRACK ] 19
LBRACK [ 19
IDENFR j 19
RBRACK ] 19
SEMICN ; 19
IDENFR j 20
ASSIGN = 20
IDENFR j 20
PLUS + 20
INTCON 1 20
SEMICN ; 20
RBRACE } 21
IDENFR k 22
ASSIGN = 22
IDENFR k 22
PLUS + 22
INTCON 1 22
SEMICN ; 22
RBRACE } 23
WHILETK while 24
LPARENT ( 24
IDENFR i 24
LSS < 24
IDENFR mid 24
RPARENT ) 24
LBRACE { 24
IDENFR buf 25
LBRACK [ 25
INTCON 1 25
RBRACK ] 25
LBRACK [ 25
IDENFR k 25
RBRACK ] 25
ASSIGN = 25
IDENFR buf 25
LBRACK [ 25
INTCON 0 25
RBRACK ] 25
LBRACK [ 25
IDENFR i 25
RBRACK ] 25
SEMICN ; 25
IDENFR i 26
ASSIGN = 26
IDENFR i 26
PLUS + 26
INTCON 1 26
SEMICN ; 26
IDENFR k 27
ASSIGN = 27
IDENFR k 27
PLUS + 27
INTCON 1 27
SEMICN ; 27
RBRACE } 28
WHILETK while 29
LPARENT ( 29
IDENFR j 29
LSS < 29
IDENFR r 29
RPARENT ) 29
LBRACE { 29
IDENFR buf 30
LBRACK [ 30
INTCON 1 30
RBRACK ] 30
LBRACK [ 30
IDENFR k 30
RBRACK ] 30
ASSIGN = 30
IDENFR buf 30
LBRACK [ 30
INTCON 0 30
RBRACK ] 30
LBRACK [ 30
IDENFR j 30
RBRACK ] 30
SEMICN ; 30
IDENFR j 31
ASSIGN = 31
IDENFR j 31
PLUS + 31
INTCON 1 31
SEMICN ; 31
IDENFR k 32
ASSIGN = 32
IDENFR k 32
PLUS + 32
INTCON 1 32
SEMICN ; 32
RBRACE } 33
WHILETK while 35
LPARENT ( 35
IDENFR l 35
LSS < 35
IDENFR r 35
RPARENT ) 35
LBRACE { 35
IDENFR buf 36
LBRACK [ 36
INTCON 0 36
RBRACK ] 36
LBRACK [ 36
IDENFR l 36
RBRACK ] 36
ASSIGN = 36
IDENFR buf 36
LBRACK [ 36
INTCON 1 36
RBRACK ] 36
LBRACK [ 36
IDENFR l 36
RBRACK ] 36
SEMICN ; 36
IDENFR l 37
ASSIGN = 37
IDENFR l 37
PLUS + 37
INTCON 1 37
SEMICN ; 37
RBRACE } 38
RBRACE } 39
INTTK int 41
MAINTK main 41
LPARENT ( 41
RPARENT ) 41
LBRACE { 42
INTTK int 43
IDENFR n 43
ASSIGN = 43
IDENFR getarray 43
LPARENT ( 43
IDENFR buf 43
LBRACK [ 43
INTCON 0 43
RBRACK ] 43
RPARENT ) 43
SEMICN ; 43
IDENFR merge_sort 44
LPARENT ( 44
INTCON 0 44
COMMA , 44
IDENFR n 44
RPARENT ) 44
SEMICN ; 44
IDENFR putarray 45
LPARENT ( 45
IDENFR n 45
COMMA , 45
IDENFR buf 45
LBRACK [ 45
INTCON 0 45
RBRACK ] 45
RPARENT ) 45
SEMICN ; 45
RETURNTK return 46
INTCON 0 46
SEMICN ; 46
RBRACE } 47
